(window.webpackJsonp=window.webpackJsonp||[]).push([[8],{170:function(t,a,e){"use strict";e.r(a);var n=e(0),r=Object(n.a)({},function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("div",{staticClass:"content"},[t._m(0),t._v(" "),e("p",[t._v("ECMAScript规范给所有的函数都定义了call和apply两个方法，应用十分广泛，作用一样，但是传参形式有点区别")]),t._v(" "),t._m(1),t._v(" "),t._m(2),t._v(" "),t._m(3),t._v(" "),t._m(4),t._v(" "),t._m(5),t._v(" "),e("p",[t._v("在这里增加一个bind方法，bind是EcmaScript5中扩展的方法，它的用法和call十分相似")]),t._v(" "),t._m(6),t._v(" "),t._m(7),t._v(" "),t._m(8),t._v(" "),t._m(9),e("p",[t._v("从上面我们可以看到bind与call不同，当调用call的时候，会立即执行相应的函数，而bind则会将相应的this和参数传给参数，然后返回一个新的参数，而不会立即执行。\n2. 参数的使用不同\nfunction func(a, b, c) {")]),t._v(" "),t._m(10),e("p",[t._v("上面可以看到call只是把第二个和后面的参数传进去，而bind是第一次调用的时候，把参数传进去，然后返回的新的函数，这个函数也可以传进去新的参数，而位置从之前初始化时传进参数的下一个开始，当传进的参数过多的时候，后面的参数自动被省略。")]),t._v(" "),t._m(11),t._v(" "),e("p",[t._v("先来个结果：当参数少于三个的时候，call的性能会比apply高。")]),t._v(" "),t._m(12),t._v(" "),e("p",[t._v("一篇github上的实验文章\n"),e("a",{attrs:{href:"https://github.com/noneven/__/issues/6",target:"_blank",rel:"noopener noreferrer"}},[t._v("call和apply的性能对比"),e("OutboundLink")],1),t._v("\n里面的测试用到了一个神奇的网站"),e("a",{attrs:{href:"https://jsperf.com/",target:"_blank",rel:"noopener noreferrer"}},[t._v("jsperf"),e("OutboundLink")],1),t._v("，用来测试js性能。")]),t._v(" "),t._m(13),t._v(" "),e("p",[t._v("想要知道为什么call比apply快？那让我们看看它们各自被调用后发生了什么吧。")]),t._v(" "),t._m(14),t._v(" "),t._m(15),t._v(" "),t._m(16),t._v(" "),t._m(17),t._v(" "),t._m(18),t._v(" "),e("p",[t._v("我们可以看到，apply调用后的步骤比call步骤多很多，需要对参数进行检查，然后改变参数的格式，还有一点就是apply不管有多少个参数,都需要先遍历一遍。而call是需要的时候才会被执行\n结论：因此call方法比apply快的原因是由于call方法的参数格式是内部方法需要的格式，不需要进行转换。")]),t._v(" "),e("p",[e("strong",[t._v("参考和学习链接")]),t._v(" "),e("a",{attrs:{href:"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/apply",target:"_blank",rel:"noopener noreferrer"}},[t._v("MDN"),e("OutboundLink")],1),t._v(" "),e("a",{attrs:{href:"https://github.com/noneven/__/issues/6",target:"_blank",rel:"noopener noreferrer"}},[t._v("call和apply的性能对比"),e("OutboundLink")],1),t._v(" "),e("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/27659836#comments",target:"_blank",rel:"noopener noreferrer"}},[t._v("李佳怡-为什么call比apply快"),e("OutboundLink")],1)])])},[function(){var t=this.$createElement,a=this._self._c||t;return a("h1",{attrs:{id:"面试题之-call与apply详解和性能对比分析"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#面试题之-call与apply详解和性能对比分析","aria-hidden":"true"}},[this._v("#")]),this._v(" 面试题之-call与apply详解和性能对比分析")])},function(){var t=this.$createElement,a=this._self._c||t;return a("h2",{attrs:{id:"apply（）"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#apply（）","aria-hidden":"true"}},[this._v("#")]),this._v(" apply（）")])},function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ul",[e("li",[e("p",[t._v("参数：2个")]),t._v(" "),e("ol",[e("li",[t._v("一个是作为函数上下文的对象，MDN的说法是函数运行时的this值，两种说法其实是一样的。")]),t._v(" "),e("li",[t._v("作为函数参数所组成的数组，数组元素将作为单独的参数传给函数。")])])]),t._v(" "),e("li",[e("p",[t._v("例子说明：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("\tvar obj = {\n    name: 'Mike'\n}\n\nfunction func (firstparam , secondparam){\n    console.log(firstparam + this.name + secondparam );\n}\n\nfunc.apply(obj, ['hello ', ' ,how are you?'])\n // hello mike how are you?\n")])])]),e("p",[t._v("如上面例子那样，obj作为func函数运行时的this对象所指向的值，而参数hello 和 how are you？ 放在了一个数组中，作为参数传给了func函数。")])])])},function(){var t=this.$createElement,a=this._self._c||t;return a("h2",{attrs:{id:"call"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#call","aria-hidden":"true"}},[this._v("#")]),this._v(" call()")])},function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ul",[e("li",[e("p",[t._v("参数：两个")]),t._v(" "),e("ol",[e("li",[t._v("作为函数上下文的对象，MDN的说法是函数运行时的this值，两种说法其实是一样的。")]),t._v(" "),e("li",[t._v("传入一个参数列表")])])]),t._v(" "),e("li",[e("p",[t._v("例子说明")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("var obj = {\n    name: 'Mike'\n}\n\nfunction func (firstparam , secondparam){\n    console.log(firstparam + this.name + secondparam );\n}\n\nfunc.call(obj, 'hello ', ' ,how are you?')\n")])])]),e("p",[t._v("上面例子可以看到，call和apply之间的区别其实就是参数之间的不同，call是一个参数列表，而apply是一个参数数组")])])])},function(){var t=this.$createElement,a=this._self._c||t;return a("h2",{attrs:{id:"bind"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#bind","aria-hidden":"true"}},[this._v("#")]),this._v(" bind")])},function(){var t=this.$createElement,a=this._self._c||t;return a("ul",[a("li",[this._v("参数\n"),a("ol",[a("li",[this._v("函数上下文对象（与call相同）")]),this._v(" "),a("li",[this._v("参数列表（与call相同）")])])])])},function(){var t=this.$createElement,a=this._self._c||t;return a("h3",{attrs:{id:"bind与call的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#bind与call的区别","aria-hidden":"true"}},[this._v("#")]),this._v(" bind与call的区别")])},function(){var t=this.$createElement,a=this._self._c||t;return a("ol",[a("li",[this._v("bind返回值是函数")])])},function(){var t=this.$createElement,a=this._self._c||t;return a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[this._v("var obj = {\n    name: 'Mike'\n}\n\nfunction func (firstparam , secondparam){\n    console.log(firstparam + this.name + secondparam );\n}\n\nvar bind = func.bind(obj, 'hello ', ' ,how are you?')\nconsole.log(bind);\nbind();\n// [Function: bound func]\n// hello Mike ,how are you?\n")])])])},function(){var t=this.$createElement,a=this._self._c||t;return a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[this._v("    console.log(a, b, c);\n}\nvar func1 = func.bind(null,'linxin');\n\nfunc('A', 'B', 'C')；            // A B C\nfunc1('A', 'B', 'C');           // linxin A B\nfunc1('B', 'C');                // linxin B C\nfunc.call(null, 'linxin');      // linxin undefined undefined\n")])])])},function(){var t=this.$createElement,a=this._self._c||t;return a("h2",{attrs:{id:"call和apply的性能对比"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#call和apply的性能对比","aria-hidden":"true"}},[this._v("#")]),this._v(" call和apply的性能对比")])},function(){var t=this.$createElement,a=this._self._c||t;return a("h3",{attrs:{id:"性能对比的实验"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#性能对比的实验","aria-hidden":"true"}},[this._v("#")]),this._v(" 性能对比的实验")])},function(){var t=this.$createElement,a=this._self._c||t;return a("h3",{attrs:{id:"所以为什么call会比apply快呢？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#所以为什么call会比apply快呢？","aria-hidden":"true"}},[this._v("#")]),this._v(" 所以为什么call会比apply快呢？")])},function(){var t=this.$createElement,a=this._self._c||t;return a("h4",{attrs:{id:"function-prototype-apply-thisarg-argarray"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#function-prototype-apply-thisarg-argarray","aria-hidden":"true"}},[this._v("#")]),this._v(" Function.prototype.apply(thisArg, argArray)")])},function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ol",[e("li",[t._v("如果IsCallable（Function）为false，即Function不可以被调用，则抛出一个TypeError异常。")]),t._v(" "),e("li",[t._v("如果argArray为null或未定义，则返回调用Function的[[Call]]内部方法的结果，提供thisArg一个空数组作为参数。")]),t._v(" "),e("li",[t._v("如果Type（argArray）不是Objcet，则抛出TypeError异常。")]),t._v(" "),e("li",[t._v("获取argArray的长度。调用argArray的[[Get]]内部方法，找到属性length。赋值给len。")]),t._v(" "),e("li",[t._v("定义n为ToUint32（len）。")]),t._v(" "),e("li",[t._v("初始化argList为空列表")]),t._v(" "),e("li",[t._v("初始化index为0.")]),t._v(" "),e("li",[t._v("循环迭代取出argArray。重复循环while（index < n）\n"),e("ul",[e("li",[t._v("将下标转换成String类型。初始化indexName为ToString（index）")]),t._v(" "),e("li",[t._v("定义nextArg为使用indexName作为参数调用argArray的[[Get]]内部方法的结果")]),t._v(" "),e("li",[t._v("将nextArg添加到argList中，作为最后一个元素")]),t._v(" "),e("li",[t._v("设置index = index + 1")])])]),t._v(" "),e("li",[t._v("返回调用Function的[[Call]]内部方法的结果，提供thisArg作为该值，argList作为参数列表")])])},function(){var t=this.$createElement,a=this._self._c||t;return a("h4",{attrs:{id:"function-prototype-call-thisarg-arg1-arg2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#function-prototype-call-thisarg-arg1-arg2","aria-hidden":"true"}},[this._v("#")]),this._v(" Function.prototype.call(thisArg, [arg1, arg2, ....])")])},function(){var t=this.$createElement,a=this._self._c||t;return a("ol",[a("li",[this._v("如果IsCallable（Function）为false,即function 不可以被调用，则抛出一个TypeError异常")]),this._v(" "),a("li",[this._v("定义argList为一个空列表")]),this._v(" "),a("li",[this._v("如果使用超过一个参数调用此方法则以arg1开始的从左到右的顺序将每个参数附加为argList的最后一个元素")]),this._v(" "),a("li",[this._v("返回调用func的[[Call]]内部方法的结果，提供thisArg作为该值，argLIst作为参数列表。")])])},function(){var t=this.$createElement,a=this._self._c||t;return a("h4",{attrs:{id:"结论"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#结论","aria-hidden":"true"}},[this._v("#")]),this._v(" 结论")])}],!1,null,null,null);a.default=r.exports}}]);