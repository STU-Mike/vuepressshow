(window.webpackJsonp=window.webpackJsonp||[]).push([[6],{172:function(a,t,e){"use strict";e.r(t);var r=e(0),i=Object(r.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var a=this,t=a.$createElement,e=a._self._c||t;return e("div",{staticClass:"content"},[e("h1",{attrs:{id:"缓存知识"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#缓存知识","aria-hidden":"true"}},[a._v("#")]),a._v(" 缓存知识")]),a._v(" "),e("p",[a._v("###缓存的优点\n缓存可以很有效地降低网络的时延，同时也会减少大量请求对于服务器的压力。")]),a._v(" "),e("ol",[e("li",[a._v("减少冗余的数据传输，可节省流量")]),a._v(" "),e("li",[a._v("缓解带宽瓶颈问题，可更快加载页面")]),a._v(" "),e("li",[a._v("缓解瞬间拥塞，可缓解原始服务器的压力")]),a._v(" "),e("li",[a._v("降低距离延时，加快响应速度\n##缓存分类")]),a._v(" "),e("li",[a._v("地址栏网址缓存")]),a._v(" "),e("li",[a._v("检查HSTS预加载列表")]),a._v(" "),e("li",[a._v("DNS缓存")]),a._v(" "),e("li",[a._v("ARP（地址解析协议）缓存")]),a._v(" "),e("li",[a._v("TCP发送缓冲区&接受缓冲区")]),a._v(" "),e("li",[a._v("HTTP请求缓存（CDN节点缓存、代理服务器缓存、浏览器缓存、后端动态计算结果缓存等）")])]),a._v(" "),e("h2",{attrs:{id:"地址栏网址缓存"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#地址栏网址缓存","aria-hidden":"true"}},[a._v("#")]),a._v(" 地址栏网址缓存")]),a._v(" "),e("p",[a._v("例子：我们在浏览器地址栏中输入几个字母，浏览器就自动帮我们补全了网址，这就是地址栏网址缓存\n特点：当我们使用地址栏缓存的网址时，请求的相关静态资源也是从缓存中取得的\n注意：不论什么时候，我们获取的主页面资源timeline都应该是重新请求服务器而获得的，不可以使用本地浏览器的缓存。")]),a._v(" "),e("h3",{attrs:{id:"转换非ascii的unicode字符"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#转换非ascii的unicode字符","aria-hidden":"true"}},[a._v("#")]),a._v(" 转换非ASCII的Unicode字符")]),a._v(" "),e("p",[a._v("当浏览器检查到输入中含有不是A-Z、a—z、0-9、-或者.的字符时，就会把这些字符进行Punycode编码，将其转换为DNS系统的编码")]),a._v(" "),e("h2",{attrs:{id:"检查hsts预加载列表"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#检查hsts预加载列表","aria-hidden":"true"}},[a._v("#")]),a._v(" 检查HSTS预加载列表")]),a._v(" "),e("p",[a._v("HSTS：这个是关于web安全的心协议，作用是强制客户端（如浏览器）使用HTTPS与服务器创建连接。\n作用的过程：在支持这个协议的浏览器，在输入URL后会检查自带的HSTS预加载列表（这个列表里包含了哪些请求浏览器只使用HTTPS进行连接的域名），若网站在这个列表里，浏览器会使用HTTPS协议并且返回码307.而不支持HSTS的浏览器访问我们的网站，则不会产生跳转，从而提高了兼容性。这个机制对于不支持HTTPS的搜索引擎来说是非常友好的。")]),a._v(" "),e("h2",{attrs:{id:"dns-缓存"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#dns-缓存","aria-hidden":"true"}},[a._v("#")]),a._v(" DNS 缓存")]),a._v(" "),e("p",[a._v("一旦输入域名然后按下回车后，就会开始对域名进行解析。域名解析最少涉及三个的缓存")]),a._v(" "),e("ol",[e("li",[a._v("浏览器的DNS缓存")]),a._v(" "),e("li",[a._v("操作系统中的DNS缓存")]),a._v(" "),e("li",[a._v("操作系统的hosts文件（可手动写入的缓存）\n域名解析过程")]),a._v(" "),e("li",[a._v("首先是浏览器搜索自己的DNS缓存；没有命中则进入下一步")]),a._v(" "),e("li",[a._v("搜索操作系统中的DNS缓存；没有命中则进入下一步")]),a._v(" "),e("li",[a._v("搜索操作系统的hosts；如果没有则进入下一步")]),a._v(" "),e("li",[a._v("操作系统将域名发送至LDNS（本地区域名服务器），LDNS查询自己的DNS缓存（一般命中率在80%左右），查询结果则返回结果，失败则发起一个迭代DNS解析请求")]),a._v(" "),e("li",[a._v("LDNS向Root Name Server（根域名服务器，如com、net、im等的顶级域名服务器的地址发起请求，此处，Root Name Server返回im域的顶级域名服务器的地址）；")]),a._v(" "),e("li",[a._v("LDNS向juejin.im域名服务器发起请求，得到juejin.im的IP地址")]),a._v(" "),e("li",[a._v("LDNS将得到的IP地址返回给操作系统，同时自己也将IP地址缓存起来；操作系统将IP地址返回给浏览器，同时自己也将IP地址缓存起来。")])]),a._v(" "),e("h3",{attrs:{id:"dns-prefetch"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#dns-prefetch","aria-hidden":"true"}},[a._v("#")]),a._v(" DNS Prefetch")]),a._v(" "),e("p",[a._v("DNS预获取，也是前端优化的一部分，前端优化中与DNS有关的两点：")]),a._v(" "),e("ol",[e("li",[a._v("减少DNS的请求次数")]),a._v(" "),e("li",[a._v("进行DNS预获取\nDNS Prefetching让具有此属性的域名不需要用户点击链接就在后台解析，而域名解析和内容载入是串行的网络操作，所以这个方式能减少用户的等待时间，提升用户体验\n注意：浏览器DNS缓存时间一般不会太长，一分钟左右，为什么不设置长时间呢？这是因为缓存时间过长会影响DNS在IP变更时不能及时解析到最新的IP")])]),a._v(" "),e("h2",{attrs:{id:"apr（地址解析协议）缓存"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#apr（地址解析协议）缓存","aria-hidden":"true"}},[a._v("#")]),a._v(" APR（地址解析协议）缓存")]),a._v(" "),e("blockquote",[e("p",[a._v("ARP 是一种用以解析地址的协议，根据通信方的IP地址就可以查出对应方的MAC地址\nARP缓存是个用来存储IP地址和MAC地址的缓冲区，其本质就是一个IP地址与MAC地址的对应表，表中每一个条目分贝记录了其他主机的IP地址和对应的MAC地址\n当地址解析协议被询问一个已知IP地址节点的MAC地址时，现在AR缓存中查看，若存在，就直接返回与之对应的MAC地址；若不存在，才发送ARP请求查询。")])]),a._v(" "),e("h2",{attrs:{id:"tcp发送缓冲区-接受缓冲区"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#tcp发送缓冲区-接受缓冲区","aria-hidden":"true"}},[a._v("#")]),a._v(" TCP发送缓冲区&接受缓冲区")]),a._v(" "),e("p",[a._v("在建立TCP连接这一步中也涉及到缓存，作用是用来存放通信数据不会丢包\n每个TCP连接在内核中都有一个"),e("strong",[a._v("发送缓冲区")]),a._v("和"),e("strong",[a._v("接受缓冲区")]),a._v("，TCP的全双工的工作模式以及TCP的流量（拥塞）控制便是依赖于这两个独立的buffer以及buffer的填充状态")]),a._v(" "),e("h3",{attrs:{id:"发送缓冲区"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#发送缓冲区","aria-hidden":"true"}},[a._v("#")]),a._v(" 发送缓冲区")]),a._v(" "),e("blockquote",[e("p",[a._v("发送缓冲区存放的是send（）方法从应用缓冲区拷贝过来的数据\n其中内核是按照MSS（最大报文段长度）从缓冲区中取数据发送出去，当缓存区中的数据小于MSS，则会将剩余的数据都发送出去。TCP的发送缓冲区必须为已发送的数据保留一个副本，知道它被对端确认为止，才会删除。")])]),a._v(" "),e("h3",{attrs:{id:"接受缓冲区"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#接受缓冲区","aria-hidden":"true"}},[a._v("#")]),a._v(" 接受缓冲区")]),a._v(" "),e("blockquote",[e("p",[a._v("接受缓冲区被TCP用来保存接收到的数据，直到应用程序来读取\n接受缓冲区把数据缓存入内核，等到recv（）方法读取，recv（）方法所做的工作，就是把内核缓冲区中的数据拷贝到应用层用户的buffer里面，拷贝后就删除已确认的数据")])]),a._v(" "),e("h3",{attrs:{id:"流控制（flow-control）"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#流控制（flow-control）","aria-hidden":"true"}},[a._v("#")]),a._v(" 流控制（Flow control）")]),a._v(" "),e("p",[a._v("TCP流控制的作用就是匹配发送端和接受端的速度，简单来说就是根据接受端的接受能力来调整发送端的发送速度")]),a._v(" "),e("h2",{attrs:{id:"http请求缓存（cdn节点缓存、代理服务器缓存、浏览器缓存、后端动态计算结果缓存等）"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#http请求缓存（cdn节点缓存、代理服务器缓存、浏览器缓存、后端动态计算结果缓存等）","aria-hidden":"true"}},[a._v("#")]),a._v(" HTTP请求缓存（CDN节点缓存、代理服务器缓存、浏览器缓存、后端动态计算结果缓存等）")]),a._v(" "),e("p",[a._v("建立TCP连接后就是HTTP请求了，"),e("strong",[a._v("HTTP缓存是优化性能不可忽视的一部分")])]),a._v(" "),e("h3",{attrs:{id:"强缓存（cache-control-和-expires）"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#强缓存（cache-control-和-expires）","aria-hidden":"true"}},[a._v("#")]),a._v(" 强缓存（Cache-Control 和 Expires）")]),a._v(" "),e("p",[a._v("强缓存主要是采用"),e("strong",[a._v("响应头")]),a._v("中的Cache-Control和Expires两个字段进行控制的\nExpires：定义于HTTP1.0.它指定一个绝对的过期时期。\nCache-Control：定义于HTTP1.1，是一个缓存控制字段。\n**注意：**这两个字段同时使用的时候Cache-Control的优先级会更高\n作用：客户端会通过对比本地时间和服务器的生存时间来检测缓存是否可用。如果缓存没有超出它的生存时间，客户端就会直接采用本地的缓存。如果生存日期已经过了，客户端将再次与服务器进行通信来验证这个缓存是否需要更新。")]),a._v(" "),e("h3",{attrs:{id:"协商缓存（last—modified和etag）"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#协商缓存（last—modified和etag）","aria-hidden":"true"}},[a._v("#")]),a._v(" 协商缓存（Last—Modified和Etag）")]),a._v(" "),e("p",[a._v("协商缓存就是浏览器需要向服务器询问缓存的相关信息，进而判断是否要重新发起请求还是从本地获取缓存的资源。如果服务器说缓存资源未改动，资源会被重定向到浏览器缓存，这种情况下网络请求对应的状态是304\nLast-Modified 和 if-Modified-Since\n当客户端再次请求该资源的时候，会在其请求头上附带if-Modified-Since（值就是第一次获取请求资源时响应头中返回的Last-Modified值）。如果时间未改变表明资源未过期，命中缓存，服务器就直接返回304状态，客户端直接使用本地的资源。否则，服务器重新发送响应资源，保证资源有效性。")]),a._v(" "),e("h3",{attrs:{id:"etag和if-none—match"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#etag和if-none—match","aria-hidden":"true"}},[a._v("#")]),a._v(" Etag和If-None—Match")]),a._v(" "),e("blockquote",[e("p",[a._v("基于资源校验码（一般为md5值）而检验缓存的过期机制\n当客户端再次发送请求该资源的时候，会在其请求头上附带If-None—Match字段（值就是第一次获取请求资源时响应头中返回的Etag值），其值与服务器端资源文件的验证码进行对比，如果匹配成功直接返回304状态码，从浏览器本地缓存取资源文件，如果不匹配，服务器会把新的验证码放在请求头的Etag字段中，并且以200状态吗返回资源\n注意：当响应头中同时存在Etag和Last—Modified的时候，会先对Etag进行对比，然后才是Last-Modified")])]),a._v(" "),e("h3",{attrs:{id:"etag的问题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#etag的问题","aria-hidden":"true"}},[a._v("#")]),a._v(" Etag的问题")]),a._v(" "),e("p",[a._v("相同资源，在两台服务器产生的Etag是不相同的，所以对于使用服务器集群来处理请求的网站来说，Etag的匹配概率会大幅降低，所以在这种情况下，使用Etag来处理缓存，反而会有更大开销。")]),a._v(" "),e("h2",{attrs:{id:"静态资源和动态资源的请求过程解析"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#静态资源和动态资源的请求过程解析","aria-hidden":"true"}},[a._v("#")]),a._v(" 静态资源和动态资源的请求过程解析")]),a._v(" "),e("p",[a._v("未完...")])])}],!1,null,null,null);t.default=i.exports}}]);