(window.webpackJsonp=window.webpackJsonp||[]).push([[9],{169:function(e,t,a){"use strict";a.r(t);var s=a(0),r=Object(s.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("div",{staticClass:"content"},[a("h1",{attrs:{id:"nodejs-模块系统知识点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#nodejs-模块系统知识点","aria-hidden":"true"}},[e._v("#")]),e._v(" nodejs 模块系统知识点")]),e._v(" "),a("h2",{attrs:{id:"为什么要模块系统"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#为什么要模块系统","aria-hidden":"true"}},[e._v("#")]),e._v(" 为什么要模块系统")]),e._v(" "),a("p",[e._v("是为了让nodejs的文件可以互相调用。")]),e._v(" "),a("h2",{attrs:{id:"模块是什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#模块是什么","aria-hidden":"true"}},[e._v("#")]),e._v(" 模块是什么")]),e._v(" "),a("p",[e._v("模块是Node.js应用程序的基本组成部分，文件和模块是一一对应的，也就是说一个Node.j文件就是一个模块.")]),e._v(" "),a("h2",{attrs:{id:"创建模块"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#创建模块","aria-hidden":"true"}},[e._v("#")]),e._v(" 创建模块")]),e._v(" "),a("p",[e._v("nodejs提供了exports和require两个对象，")]),e._v(" "),a("ol",[a("li",[e._v("exports：是模块公开的接口")]),e._v(" "),a("li",[e._v("require：用户从外部获取一个模块的接口，即获取模块的exports对象\n例子代码\n下面是用require（'./Hello'）引入当前目录下的hello.js文件（其中./为当前目录，node.js默认后缀为js）")])]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("var hello = require('./hello');\nhello.world();\n")])])]),a("p",[e._v("下面是hello.js文件的内容")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("exports.world = function() {\n  console.log('Hello World');\n}\n")])])]),a("p",[e._v("上面示例中，hello.js通过exports对象吧world作 为模块的访问接口，在main.js中通过require('./hello')加载这个模块，然后就可以直接访问hello.js中exports对象的成员函数了。")]),e._v(" "),a("h3",{attrs:{id:"把一个对象封装到模块中"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#把一个对象封装到模块中","aria-hidden":"true"}},[e._v("#")]),e._v(" 把一个对象封装到模块中")]),e._v(" "),a("p",[e._v("简单来说就是把这个对象赋值给export（模块的接口）\n格式如下")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("module.exports = function() {\n  // ...\n}\n")])])]),a("p",[e._v("例子")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("//hello.js \nfunction Hello() { \n    var name; \n    this.setName = function(thyName) { \n        name = thyName; \n    }; \n    this.sayHello = function() { \n        console.log('Hello ' + name); \n    }; \n}; \nmodule.exports = Hello;\n")])])]),a("p",[e._v("注意module（模块）.exports（接口） = hello ，就是把hello赋值给了接口，\n使用：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("//main.js \nvar Hello = require('./hello'); \nhello = new Hello(); \nhello.setName('BYVoid'); \nhello.sayHello(); \n")])])]),a("p",[e._v("模块接口的唯一变化是使用module.exports=Hello 代替了exports.world = function(){}。 在外部引用该模块时，其接口对象就是要输出的Hello对象本身，而不是原先的exports")]),e._v(" "),a("blockquote",[a("p",[e._v("exports 和 module.exports 的使用\n如果要对外暴露属性或方法，就用 exports 就行，要暴露对象(类似class，包含了很多属性和方法)，就用 module.exports。")])]),e._v(" "),a("h2",{attrs:{id:"服务端的模块放在哪里"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#服务端的模块放在哪里","aria-hidden":"true"}},[e._v("#")]),e._v(" 服务端的模块放在哪里")]),e._v(" "),a("p",[e._v('之前我们就已经使用过模块了\n比如：\nvar http = require("http");')]),e._v(" "),a("p",[e._v("...")]),e._v(" "),a("p",[e._v("http.createServer(...);\nnodejs中自带了一个叫做http的模块，我们在我们的diamante中请求它并返回值赋给一个本地变量。这把我们本地变量变成了一个拥有所有http模块所提供的公共方法的对象。\nnodejs的require方法中的文件查找策略如下\nnodejs有四类模块：原生模块和3中文件模块\n各个模块的加载优先级不同\n优先级：文件模块缓存区>原生模块缓存区>未缓存的原生模块>文件模块")]),e._v(" "),a("h4",{attrs:{id:"文件模块缓存"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#文件模块缓存","aria-hidden":"true"}},[e._v("#")]),e._v(" 文件模块缓存")]),e._v(" "),a("p",[e._v("优先级最高")]),e._v(" "),a("h4",{attrs:{id:"原生模块缓存区"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#原生模块缓存区","aria-hidden":"true"}},[e._v("#")]),e._v(" 原生模块缓存区")]),e._v(" "),a("p",[e._v("优先级次于文件模块换缓存。require方法在解析文件名之后，优先检查模块是否在原生模块列表中，以http模块为例，尽管在目录下存在一个http/http.js/http.node/http.json文件，require（”http“）都不会从这些文件中加载，而是从原生模块中加载\n原生模块也有一个缓存区，同样也是优先从缓存区加载，如果没有被加载过，则调用原生模块的加载方式进行加载和执行。")]),e._v(" "),a("h4",{attrs:{id:"从文件加载"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#从文件加载","aria-hidden":"true"}},[e._v("#")]),e._v(" 从文件加载")]),e._v(" "),a("p",[e._v("当文件模块缓存中不存在，而且不是原生模块的时候，nodejs会解析requeire方法传入的参数，并从文件系统中加载实际的文件，\nrequire方法接受几种参数的传递")]),e._v(" "),a("ul",[a("li",[e._v("http、fs、path等，原生模块")]),e._v(" "),a("li",[e._v("./mod或../mod,相对路径的文件模块")]),e._v(" "),a("li",[e._v("/pathtomodule/mod,绝对路径的文件模块")]),e._v(" "),a("li",[e._v("mod，非原生模块的文件模块。\n##全局变量\n_dirname:表示当前执行脚本所在的目录\n_filename:表示当前正在执行的脚本的文件名。它将输出文件所在位置的绝对路径。如果在模块中，返回的值是模块文件的路径。")])]),e._v(" "),a("p",[e._v('###介绍一个path.join()\n用于连接路径。该方法的主要用途在于，会正确使用当前系统的路径分隔符，Unix系统是"/"，Windows系统是""。')])])}],!1,null,null,null);t.default=r.exports}}]);